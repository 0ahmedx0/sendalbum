import asyncio
import os
import random
from dotenv import load_dotenv
from pyrogram import Client, errors
from pyrogram.types import InputMediaPhoto, InputMediaVideo, InputMediaDocument

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ù† Ù…Ù„Ù .env
load_dotenv()

API_ID = int(os.getenv("API_ID", "0"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
SOURCE_ID = int(os.getenv("CHANNEL_ID"))         # â† chat_id Ù„Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø®Ø§ØµØ©
DEST_ID = int(os.getenv("CHANNEL_ID_LOG"))       # â† chat_id Ù„Ù„Ù‚Ù†Ø§Ø© Ø§Ù„ÙˆØ¬Ù‡Ø©
FIRST_MSG_ID = int(os.getenv("FIRST_MSG_ID", "1"))
LAST_MESSAGE_ID = int(os.getenv("LAST_MESSAGE_ID", ""))
BATCH_SIZE = 1000

# Ù…ØªØºÙŠØ± Ù„ØªØ®Ø²ÙŠÙ† Ø¢Ø®Ø± Ù‚ÙŠÙ…Ø© ØªØ£Ø®ÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ
prev_delay = None

def get_random_delay(min_delay=5, max_delay=40, min_diff=10):
    global prev_delay
    delay = random.randint(min_delay, max_delay)
    while prev_delay is not None and abs(delay - prev_delay) < min_diff:
        delay = random.randint(min_delay, max_delay)
    prev_delay = delay
    return delay

async def fetch_messages_in_range(client: Client, chat_id: int, first_id: int, last_id: int):
    messages = []
    offset_id = last_id + 1
    while True:
        batch = []
        async for message in client.get_chat_history(chat_id, offset_id=offset_id, limit=1000):
            if message.id < first_id:
                break
            batch.append(message)
        if not batch:
            break
        messages.extend(batch)
        offset_id = batch[-1].id
        if batch[-1].id < first_id:
            break
    messages = [m for m in messages if m.id >= first_id]
    messages.sort(key=lambda m: m.id)
    return messages

def chunk_messages(messages, chunk_size):
    for i in range(0, len(messages), chunk_size):
        yield messages[i:i+chunk_size]

def group_albums(messages):
    albums = {}
    for msg in messages:
        if msg.media_group_id:
            albums.setdefault(msg.media_group_id, []).append(msg)
    return albums

async def send_album(client: Client, dest_chat_id: int, source_chat_id: int, messages: list):
    album_messages = messages  
    media_group = []
    for idx, msg in enumerate(album_messages):
        if msg.photo:
            media = InputMediaPhoto(msg.photo.file_id)
        elif msg.video:
            media = InputMediaVideo(msg.video.file_id, supports_streaming=True)
        elif msg.document:
            if msg.document.mime_type.startswith('video/'):
                media = InputMediaVideo(msg.document.file_id, supports_streaming=True)
            else:
                media = InputMediaDocument(msg.document.file_id)
        else:
            continue
        if idx == 0 and msg.caption:
            media.caption = msg.caption
        media_group.append(media)
    try:
        await client.send_media_group(dest_chat_id, media_group)
        print(f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø£Ù„Ø¨ÙˆÙ… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {[msg.id for msg in album_messages]}")
    except errors.FloodWait as e:
        print(f"â³ FloodWait: Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {e.value} Ø«Ø§Ù†ÙŠØ©...")
        await asyncio.sleep(e.value + 5)
        await send_album(client, dest_chat_id, source_chat_id, messages)
    except Exception as e:
        print(f"âš ï¸ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù„Ø¨ÙˆÙ…: {str(e)}")

async def process_channel(client: Client, source_id: int, dest_id: int):
    try:
        source_chat = await client.get_chat(source_id)
        print("âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…ØµØ¯Ø±")
    except Exception as e:
        print(f"âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…ØµØ¯Ø±: {e}")
        return

    try:
        dest_chat = await client.get_chat(dest_id)
        print("âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„ÙˆØ¬Ù‡Ø©")
    except Exception as e:
        print(f"âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„ÙˆØ¬Ù‡Ø©: {e}")
        return

    print("ğŸ” Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ø­Ø¯Ø¯...")
    all_messages = await fetch_messages_in_range(client, source_chat.id, FIRST_MSG_ID, LAST_MESSAGE_ID)
    print(f"ğŸ” ØªÙ… Ø¬Ù„Ø¨ {len(all_messages)} Ø±Ø³Ø§Ù„Ø© Ø¶Ù…Ù† Ø§Ù„Ù†Ø·Ø§Ù‚")

    for batch in chunk_messages(all_messages, BATCH_SIZE):
        albums = group_albums(batch)
